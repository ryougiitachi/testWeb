--Oracle的优化器有几种——基于规则的优化器，基于成本的优化器
--参考文章：https://www.cnblogs.com/kerrycode/p/3842215.html
--基于规则的优化器(RBO, Rule-based Optimization)
--自6开始引入9i及其以前使用，10g的时候被彻底丢弃；这种在生成执行计划的时候严格按照SQL语句的顺序，FROM子句表名的顺序，WHERE子句条件的顺序等一些列规则，严格遵循这些规则生成，而不会考虑表数据量等因素。
--FROM子句：执行器按照从后往前的顺序处理，写在最后的表最先被处理，最后的表可以作为驱动表，一般是小表驱动大表；如果有三个以上表连接，可以视情况将交叉表作为驱动表。
--WHERE子句：执行器采用自下而上顺序解析，可以过滤掉最大数据量的条件写到最后面，所以需要将表连接条件写在最前面的位置。
--在选择访问索引时，尽可能走可选择性(selectivity)高的索引；所谓可选择性就是一个索引的唯一键值与所存行数的比值，通常不会大于1，该值越接近1的索引效率越高，这个值可以通过查询数据字典求出。
--基于成本的优化器(CBO, Cost-based Optimization)
--自8i开始引入，9i逐步优化，10g正式取代RBO。

--行源(Row Source)与驱动表
--行源在查询中符合条件行的集合；驱动表适用于嵌套循环与哈希连接的概念，虽然叫表但在执行中可以认为是行源，所谓“小表驱动大表”，不见得是数据总量上的小表大表，在某次查询中返回较少的行源也可以被看作是小表，即使这个表中的数据总量更大。

--参考文章：http://blog.csdn.net/lifetragedy/article/details/51320192
--表连接方式
--排序合并连接(Sort Merge Join, SMJ)
--嵌套循环(Nested Loops, NL)
--驱动表的概念通常被用到这种连接方式，也是最常用的连接方式，小表驱动大表，即小表为外层表，大表为内层表，理论上可以减少循环次数，减少IO量。
--哈希连接(Hash Join, HJ)
--7之后引入的，理论上比嵌套与排序合并高效，只能用在CBO优化器中，
--笛卡尔
--什么条件都不加的时候就是这种方式，如果没有星型连接等特殊需求的话不要用这种形式。

--Hint(提示)
--7开始引用的，8i开始完善，在CBO下不要轻易加hint。

--指定优化器
--可以使用hint在执行时指定优化器，
--/*+rule*/ 使用RBO模式，忽略表与索引统计信息(即表分析信息)；可以在认为CBO的方案不好的时候使用。
--/*+all_rows*/ 使用CBO模式，依赖于表分析信息，意在提供最佳吞吐量与最小资源消耗，倾向于全表扫描，不适用与OLTP系统。
--/*+first_rows*/ 使用CBO模式，依赖于表分析信息，用于提供最快反应时间。

--在SQLPLUS下开启执行计划AUTOTRACE
>set autotrace off 						--不生成autotrace 报告，这是缺省模式
>set autotrace on explain  				--autotrace只显示优化器执行路径报告
>set autotrace on statistics 			--只显示执行统计信息，相当于执行了一遍
>set autotrace on 						--包含执行计划和统计信息，相当于执行了一遍
>set autotrace traceonly 				--同set autotrace on，但是不显示查询输
