--测试：唯一索引和在有唯一性约束的列上创建普通索引是否有区别？
--结果：某个有唯一性约束的列在创建约束的时候会自动创建唯一性索引，所以该列索引和普通索引肯定有区别，问题是创建了唯一性索引之后是否还能在该列创建普通索引(不能)。创建唯一索引之后数据库会把该表rowid存入索引中，精确查询数据时总是会最终引导到rowid。

--测试：在某列创建唯一索引和唯一约束是否有区别
--结果：两个都会建立唯一索引，唯一约束会比唯一索引多一个constraint(在plsqldeveloper10里面没有显示，但keys中却显示了，不知是不是因为类型是U所以显示到了keys页)。在plsqldeveloper的indexes页中两种索引的显示也有所不同，索引的可以随意操作，约束的是黑的，应该是因为约束的索引不能直接操作，只能通过更改约束子句修改。
--过程
--创建惟一主键的
CREATE TABLE T_TST_UQ_IDX(
	TST_ID NUMBER,
	TST_NAME VARCHAR2(20)
);
CREATE UNIQUE INDEX IDX_TST_UQ_IDX_UQ_ID ON T_TST_UQ_IDX(TST_ID);
--有唯一性约束的
CREATE TABLE T_TST_UQ_CON(
	TST_ID NUMBER,
	TST_NAME VARCHAR2(20)
);
ALTER TABLE T_TST_UQ_CON ADD CONSTRAINT UQ_TST_UQ_CON_ID UNIQUE(TST_ID);
--ALTER TABLE T_TST_UQ_CON MODIFY CONSTRAINT UQ_TST_UQ_IDX_ID RENAME UQ_TST_UQ_CON_ID;--不对
--ALTER TABLE T_TST_UQ_CON DROP CONSTRAINT UQ_TST_UQ_IDX_ID;
SELECT A.* FROM T_TST_UQ_IDX A;
SELECT A.* FROM T_TST_UQ_CON A;
--DROP TABLE T_TST_UQ_IDX;
--DROP TABLE T_TST_UQ_CON;

--测试：唯一索引与唯一约束是否都能插入多个null
--结果：两个都可以。插入重复数据后的报错是一样的，都是ORA-00001违反唯一性约束；在用is-not-null条件查询的时候两个都没有走索引，不知是不是因为数据量比较少有没有做表分析。
--过程
--索引的
INSERT INTO T_TST_UQ_IDX(TST_ID, TST_NAME) VALUES(NULL, 'NULL1');
INSERT INTO T_TST_UQ_IDX(TST_ID, TST_NAME) VALUES(NULL, 'NULL2');
INSERT INTO T_TST_UQ_IDX(TST_ID, TST_NAME) VALUES(NULL, 'NULL3');
INSERT INTO T_TST_UQ_IDX(TST_ID, TST_NAME) VALUES(NULL, 'NULL4');
INSERT INTO T_TST_UQ_IDX(TST_ID, TST_NAME) VALUES(NULL, 'NULL5');
INSERT INTO T_TST_UQ_IDX(TST_ID, TST_NAME) VALUES(NULL, 'NULL6');
INSERT INTO T_TST_UQ_IDX(TST_ID, TST_NAME) VALUES(NULL, 'NULL7');
INSERT INTO T_TST_UQ_IDX(TST_ID, TST_NAME) VALUES(NULL, 'NULL8');
INSERT INTO T_TST_UQ_IDX(TST_ID, TST_NAME) VALUES(1, 'NAME1');
INSERT INTO T_TST_UQ_IDX(TST_ID, TST_NAME) VALUES(1, 'NAME2');
--约束的
INSERT INTO T_TST_UQ_CON(TST_ID, TST_NAME) VALUES(NULL, 'NULL1');
INSERT INTO T_TST_UQ_CON(TST_ID, TST_NAME) VALUES(NULL, 'NULL2');
INSERT INTO T_TST_UQ_CON(TST_ID, TST_NAME) VALUES(NULL, 'NULL3');
INSERT INTO T_TST_UQ_CON(TST_ID, TST_NAME) VALUES(NULL, 'NULL4');
INSERT INTO T_TST_UQ_CON(TST_ID, TST_NAME) VALUES(NULL, 'NULL5');
INSERT INTO T_TST_UQ_CON(TST_ID, TST_NAME) VALUES(NULL, 'NULL6');
INSERT INTO T_TST_UQ_CON(TST_ID, TST_NAME) VALUES(NULL, 'NULL7');
INSERT INTO T_TST_UQ_CON(TST_ID, TST_NAME) VALUES(NULL, 'NULL8');
--INSERT INTO T_TST_UQ_CON(TST_ID, TST_NAME) VALUES(NULL, 'NULL9'), (NULL, 'NULL10');--oracle不支持
INSERT INTO T_TST_UQ_CON(TST_ID, TST_NAME) VALUES(1, 'NAME1');
INSERT INTO T_TST_UQ_CON(TST_ID, TST_NAME) VALUES(1, 'NAME2');

--测试：是否可以在唯一索引与唯一约束列创建普通索引
--结果：两个都不行。所有的都是报ORA-01408此列列表已索引，应该是单独创建过索引的列就不能再创建了。
--过程
--索引的
CREATE INDEX IDX_TST_UQ_IDX_ID_01 ON T_TST_UQ_IDX(TST_ID);
CREATE UNIQUE INDEX IDX_TST_UQ_IDX_ID_02 ON T_TST_UQ_IDX(TST_ID);
--约束的
CREATE INDEX IDX_TST_UQ_CON_ID_01 ON T_TST_UQ_CON(TST_ID);
CREATE UNIQUE INDEX IDX_TST_UQ_CON_ID_02 ON T_TST_UQ_CON(TST_ID);

--测试：是否可以在唯一索引与唯一约束列创建函数索引
--结果：普通函数索引可以，唯一函数索引不行，两个都是这样。应该是，因为某一列只能创建一个唯一索引吧。
--过程
--索引的
CREATE UNIQUE INDEX IDX_TST_UQ_IDX_ID_FUN ON T_TST_UQ_IDX(DECODE(TST_ID, NULL, -1, TST_ID));
--约束的
CREATE UNIQUE INDEX IDX_TST_UQ_CON_ID_FUN ON T_TST_UQ_CON(DECODE(TST_ID, NULL, -1, TST_ID));
--DROP INDEX IDX_TST_UQ_IDX_ID_FUN;
--DROP INDEX IDX_TST_UQ_CON_ID_FUN;

--测试：是否可以在已经创建唯一索引列上创建唯一性约束？反之呢？
--结果：有唯一索引的可以在该列上创建唯一性约束，反过来则不行，会提示已经有唯一主键；唯一索引与约束分着创建不同于直接创建约束，分着创建索引在indexes是白的，也就是说可以自行控制，修改约束的时候索引也不受影响；但是直接创建唯一性约束每次启动禁用的时候都会新建删除索引，删除约束之后索引页没了。keys里面的值是跟着约束走的，只有一个唯一索引keys页没有列行。
--过程
--索引的
ALTER TABLE T_TST_UQ_IDX ADD CONSTRAINT UQ_TST_UQ_IDX_ID UNIQUE(TST_ID);
--约束的
CREATE UNIQUE INDEX IDX_TST_UQ_CON_UQ_ID ON T_TST_UQ_CON(TST_ID);
