--参考文章链接
--http://zhangzhongjie.iteye.com/blog/1948093
--http://blog.csdn.net/G15738290530/article/details/51819995

--按照oracle的说法这是一种传统的执行sql方式，自从9i及其以后版本已经被execute_immediate语句大部分代替，但这个包本身在一些功能的实现上仍然有着不可取代的地位。
--可以到这个地址查找源码http://www.psoug.org
--用途：一般可以用来执行游标，和传统的语句执行游标不同，dbms_sql包是通过调用oracle包中的函数执行游标。
--使用该包执行游标需要以下步骤：
--01.DBMS_SQL.OPEN_CURSOR();					打开游标，返回一个integer的数字作为游标句柄
--02.DBMS_SQL.PARSE_CURSOR();				解析游标
--03.DBMS_SQL.BIND_VARIABLE();				绑定执行语句中的查询变量，非必须
--04.DBMS_SQL.DEFINE_COLUMN/DEFINE_ARRAY();	当需要返回值的时候定义该步骤
--05.DBMS_SQL.EXECUTE();						执行游标
--06.DBMS_SQL.FETCH_ROWS();
--07.DBMS_SQL.COLUMN_VALUE();				需要返回值的时候从游标当中取出返回值
--08.DBMS_SQL.CLOSE_CURSOR();				关闭游标

--使用该包执行查询
--查询返回单列单行的例子
DECLARE 
	V_NUM_ID NUMBER := 1;
	V_CURSOR_ID INTEGER;
	V_CURSOR_RESULT INTEGER;
	V_USERNAME T_USER.USERNAME%TYPE;
BEGIN 
	V_CURSOR_ID := DBMS_SQL.OPEN_CURSOR();
	--DBMS_SQL.NATIVE表示？
	DBMS_SQL.PARSE(V_CURSOR_ID, 'SELECT USER_ID, USERNAME, USER_STATUS, CDATE, CEATOR, EDATE, EDITOR FROM T_USER WHERE ID = :ID', DBMS_SQL.NATIVE);
	--如果sql语句中有多个同名绑定变量，那么同一个变量是否对所有同名变量起作用？
	DBMS_SQL.BIND_VARIABLE(V_CURSOR_ID, 'ID', V_NUM_ID);
	--对于要返回结果的，需要在execute之前定义返回列。第二个参数是待返回列号，从1开始；第三个是要装填的变量，在后面取值的时候也要写这个，有一点奇怪。
	DBMS_SQL.DEFINE_COLUMN(V_CURSOR_ID, 2, V_USERNAME);
	--不知道这个返回值是什么
	V_CURSOR_RESULT := DBMS_SQL.EXECUTE(V_CURSOR_ID);
	--总是很纠结要不要加then……
	WHILE(DBMS_SQL.FETCH_ROWS(V_CURSOR_ID) > 0)
	LOOP 
		--和DEFINE_COLUMN的参数差不多，还要再放一遍本地变量
		DBMS_SQL.COLUMN_VALUE(V_CURSOR_ID, 2, V_USERNAME);
	END LOOP;
	--最后关闭游标
	DBMS_SQL.CLOSE_CURSOR(V_CURSOR_ID);
EXCEPTION
	WHEN OTHERS THEN 
		DBMS_SQL.CLOSE_CURSOR(V_CURSOR_ID);
END;
/

--查询返回单列多行的例子
--CALL PRC_TEST_DBMS_SQL('SELECT USER_ID, USERNAME, CDATE FROM T_USER WHERE CDATE <= :CDATE');
CREATE OR REPLACE PROCEDURE PRC_TEST_DBMS_SQL(PV_SQL IN VARCHAR2) 
IS 
	V_CDATE DATE;
	V_CURSOR_ID INTEGER;
	V_CURSOR_RESULT INTEGER;
	V_COL_USER_ID DBMS_SQL.NUMBER_TABLE;
	V_COL_USERNAME DBMS_SQL.NUMBER_TABLE;
	V_ROWCOUNT INTEGER;
BEGIN 
	V_CDATE := TO_DATE('20180110', 'YYYYMMDD');
	V_CURSOR_ID = DBMS_SQL.OPEN_CURSOR();
	DBMS_SQL.PARSE_CURSOR(V_CURSOR_ID, PV_SQL, DBMS_SQL.NATIVE);
	DBMS_SQL.BIND_VARIABLE(V_CURSOR_ID, 'CDATE', V_CDATE);
	--一共五个参数，第三个参数列不是普通类型，是DBMS_SQL里面的类型，第四个是每次获取的的个数，不知道是不是需要保持一致，第五个可能是相对于tab里面的offset。
	DBMS_SQL.DEFINE_ARRAY(V_CURSOR_ID, 1, V_COL_USER_ID, 10, 1);
	DBMS_SQL.DEFINE_ARRAY(V_CURSOR_ID, 2, V_COL_USERNAME, 10, 1);
	V_CURSOR_RESULT := DBMS_SQL.EXECUTE(V_CURSOR_ID);
	LOOP 
		V_ROWCOUNT := DBMS_SQL.FETCH_ROWS(V_CURSOR_ID);
		EXIT WHEN V_ROWCOUNT <= 0;
		DBMS_SQL.COLUMN_VALUE(V_CURSOR_ID, 1, V_COL_USER_ID);
		DBMS_SQL.COLUMN_VALUE(V_CURSOR_ID, 2, V_COL_USERNAME);
		--不知道点和数之间用不用空格
		FOR i IN 1..V_ROWCOUNT 
		LOOP
			--回来确认一下这个函数是否支持逗号
			DBMS_OUTPUT.PUT_LINE(V_COL_USER_ID(i), V_COL_USERNAME(i));
		END LOOP;
	END LOOP;
	DBMS_SQL.CLOSE_CURSOR(V_CURSOR_ID);
EXCEPTION 
	WHEN OTHERS THEN 
		IF DBMS_SQL.IS_OPEN(V_CURSOR_ID) THEN 
			DBMS_SQL.CLOSE_CURSOR(V_CURSOR_ID);
		END IF;
END; 
/

--执行增删改语句的时候返回结果集
--与execute不同的是该包似乎会自动提交事务
--执行单行操作
CREATE OR REPLACE FUNCTION FUN_TEST_DBMS_SQL(PV_USERNAME IN VARCHAR2) 
	--返回USER_ID
	RETURN INTEGER 
IS 
	V_SQL VARCHAR2(100);
	V_USER_ID INTEGER;
	V_CURSOR_ID INTEGER;
	V_CURSOR_RESULT INTEGER;
BEGIN 
	V_SQL := 'INSERT INTO T_USER(USER_ID, USERNAME, CDATE) VALUES(SEQ_USER_ID, :USERNAME, SYSDATE) RETURNING USER_ID INTO :USER_ID';
	V_CURSOR_ID = DBMS_SQL.OPEN_CURSOR();
	DBMS_SQL.PARSE_CURSOR(V_CURSOR_ID, V_SQL, DBMS_SQL.NATIVE);
	--和列值一样，想要获取绑定变量也是上面放一遍下面放一遍，不知道为什么这么耦合
	--和类似COLUMN类似，也分为VALUE和ARRAY
	DBMS_SQL.BIND_VARIABLE(V_CURSOR_ID, 'USER_ID', V_USER_ID);
	DBMS_SQL.BIND_VARIABLE(V_CURSOR_ID, 'USERNAME', PV_USERNAME);
	DBMS_SQL.EXECUTE(V_CURSOR_ID);
	--获取绑定变量返回值的方法
	DBMS_SQL.VARIABLE_VALUE(V_CURSOR_ID, 'USER_ID', V_USER_ID);
	DBMS_OUTPUT.PUT_LINE(V_USER_ID);
	DBMS_SQL.CLOSE_CURSOR(V_CURSOR_ID);
	RETURN V_USER_ID;
EXCEPTION 
	WHEN OTHERS THEN 
		IF(DBMS_SQL.IS_OPEN(V_CURSOR_ID)) THEN 
			DBMS_SQL.CLOSE_CURSOR(V_CURSOR_ID);
		END IF;
		RETURN 0;--异常处理块中不需要返回值？
END FUN_TEST_DBMS_SQL;	--写不写都行
/

--执行多行操作
CREATE OR REPLACE PROCEDURE PRC_TEST_DBMS_SQL(PV_USERNAME IN DBMS_SQL.NUMBER_TABLE) 
IS 
	V_SQL VARCHAR2(100);
	V_USER_ID DBMS_SQL.NUMBER_TABLE;
	V_CURSOR_ID INTEGER;
	V_CURSOR_RESULT INTEGER;
BEGIN 
	V_SQL := 'INSERT INTO T_USER(USER_ID, USERNAME, CDATE) VALUES(SEQ_USER_ID, :USERNAME, SYSDATE) RETURNING USER_ID INTO :USER_ID';
	V_CURSOR_ID = DBMS_SQL.OPEN_CURSOR();
	DBMS_SQL.PARSE_CURSOR(V_CURSOR_ID, V_SQL, DBMS_SQL.NATIVE);
	--和列值一样，想要获取绑定变量也是上面放一遍下面放一遍，不知道为什么这么耦合
	DBMS_SQL.BIND_ARRAY(V_CURSOR_ID, 'USER_ID', V_USER_ID);
	DBMS_SQL.BIND_ARRAY(V_CURSOR_ID, 'USERNAME', PV_USERNAME);
	DBMS_SQL.EXECUTE(V_CURSOR_ID);
	--获取绑定变量返回值的方法
	DBMS_SQL.VARIABLE_ARRAY(V_CURSOR_ID, 'USER_ID', V_USER_ID);
	DBMS_OUTPUT.PUT_LINE(V_USER_ID);
	DBMS_SQL.CLOSE_CURSOR(V_CURSOR_ID);
EXCEPTION 
	WHEN OTHERS THEN 
		IF(DBMS_SQL.IS_OPEN(V_CURSOR_ID)) THEN 
			DBMS_SQL.CLOSE_CURSOR(V_CURSOR_ID);
		END IF;
END PRC_TEST_DBMS_SQL;	--写不写都行
/

--在执行动态sql语句时，应该选择dbms_sql还是execute_immediate的区别于取舍
--http://blog.csdn.net/tswisdom/article/details/7313805
